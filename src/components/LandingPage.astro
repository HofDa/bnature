---
import heroImg from '../assets/hero.webp';
import aboutImg from '../assets/Hummel_Raier Moos_Alois.webp';
import nilsBertolImg from '../assets/nils_bertol.webp';
import katherinaDamischImg from '../assets/katherina_damisch.webp';
import paulLutherImg from '../assets/pau_luther.webp';
import johannesRuedlImg from '../assets/johannes_ruedl.webp';
import davidHoferImg from '../assets/david_hofer.webp';
import birgithUnterthurnerImg from '../assets/birgith_unterthurner.webp';
import bnatureLogo from '../assets/bnature-logo.svg';
import type { Lang } from '../data/content';
import { content } from '../data/content';
import Header from './landing/Header.astro';
import HeroSection from './landing/HeroSection.astro';
import ServicesSection from './landing/ServicesSection.astro';
import AboutSection from './landing/AboutSection.astro';
import CollaboratorsSection from './landing/CollaboratorsSection.astro';
import FaqSection from './landing/FaqSection.astro';
import ContactSection from './landing/ContactSection.astro';
import CtaSection from './landing/CtaSection.astro';
import Footer from './landing/Footer.astro';

interface Props {
  lang: Lang;
}

const { lang } = Astro.props as Props;
const t = content[lang];
const otherLang = lang === 'de' ? 'it' : 'de';
const otherLangLabel = otherLang.toUpperCase();
const collaboratorImages = {
  nils_bertol: nilsBertolImg,
  katherina_damisch: katherinaDamischImg,
  pau_luther: paulLutherImg,
  johannes_ruedl: johannesRuedlImg,
  david_hofer: davidHoferImg,
  birgith_unterthurner: birgithUnterthurnerImg,
} as const;
---
<main class="font-body text-bark-700">
  <a href="#home" class="sr-only left-4 top-4 z-[60] rounded-md bg-white px-3 py-2 text-sm font-medium text-primary-800 focus:not-sr-only focus:absolute">
    Skip to content
  </a>

  <Header lang={lang} otherLang={otherLang} otherLangLabel={otherLangLabel} nav={t.nav} logoSrc={bnatureLogo.src} />

  <HeroSection hero={t.hero} heroImg={heroImg} />

  <ServicesSection services={t.services} />

  <AboutSection about={t.about} aboutImg={aboutImg} />

  <CollaboratorsSection collaborators={t.collaborators} collaboratorImages={collaboratorImages} />

  <FaqSection faq={t.faq} />

  <ContactSection lang={lang} contact={t.contact} />

  <CtaSection cta={t.cta} secondaryLabel={t.hero.ctaSecondary} />

  <Footer lang={lang} footer={t.footer} />
</main>
<script>
  const initScrollReveal = () => {
    const targets = Array.from(document.querySelectorAll('[data-reveal]'));
    if (!targets.length) return;
    const reduceMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

    if (reduceMotion) {
      targets.forEach((el) => el.classList.add('is-visible'));
      return;
    }

    if (!('IntersectionObserver' in window)) {
      targets.forEach((el) => el.classList.add('is-visible'));
      return;
    }

    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (!entry.isIntersecting) return;
          entry.target.classList.add('is-visible');
          observer.unobserve(entry.target);
        });
      },
      { threshold: 0.14, rootMargin: '0px 0px -6% 0px' }
    );

    targets.forEach((el) => observer.observe(el));
  };

  const initMobileMenu = () => {
    const button = document.querySelector('[data-mobile-menu-button]');
    const menu = document.querySelector('[data-mobile-menu]');
    if (!(button instanceof HTMLButtonElement) || !(menu instanceof HTMLElement)) return;
    if (button.dataset.ready === 'true') return;
    button.dataset.ready = 'true';
    const closedIcon = button.querySelector('[data-mobile-icon-closed]');
    const openIcon = button.querySelector('[data-mobile-icon-open]');
    const getMenuFocusables = () =>
      Array.from(menu.querySelectorAll('a, button, [tabindex]:not([tabindex="-1"])')).filter(
        (el) => el instanceof HTMLElement && !el.hasAttribute('disabled')
      );

    const scrollToHashTarget = (hash) => {
      if (!hash || !hash.startsWith('#') || hash.length < 2) return;
      const target = document.querySelector(hash);
      if (!(target instanceof HTMLElement)) return;

      const header = document.querySelector('[data-smart-header]');
      const headerHeight = header instanceof HTMLElement ? header.getBoundingClientRect().height : 0;
      const y = target.getBoundingClientRect().top + window.scrollY - headerHeight - 12;
      const reduceMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      window.scrollTo({ top: Math.max(0, y), behavior: reduceMotion ? 'auto' : 'smooth' });
      window.history.replaceState(null, '', hash);
    };

      const openMenu = () => {
        menu.classList.remove('max-h-0', '-translate-y-1', 'opacity-0', 'pointer-events-none');
        menu.classList.add('max-h-80', 'translate-y-0', 'opacity-100', 'pointer-events-auto', 'pb-3');
        button.setAttribute('aria-expanded', 'true');
        button.setAttribute('aria-label', 'Close navigation menu');
        menu.setAttribute('aria-hidden', 'false');
        menu.removeAttribute('inert');
        closedIcon?.classList.add('hidden');
        openIcon?.classList.remove('hidden');
        const firstLink = menu.querySelector('a');
        if (firstLink instanceof HTMLElement) firstLink.focus();
      };

    const closeMenu = (focusButton = false) => {
      menu.classList.remove('max-h-80', 'translate-y-0', 'opacity-100', 'pointer-events-auto', 'pb-3');
      menu.classList.add('max-h-0', '-translate-y-1', 'opacity-0', 'pointer-events-none');
      button.setAttribute('aria-expanded', 'false');
      button.setAttribute('aria-label', 'Open navigation menu');
      menu.setAttribute('aria-hidden', 'true');
      menu.setAttribute('inert', '');
      openIcon?.classList.add('hidden');
      closedIcon?.classList.remove('hidden');
      if (focusButton) button.focus();
    };

    button.addEventListener('click', () => {
      const isOpen = button.getAttribute('aria-expanded') === 'true';
      if (isOpen) {
        closeMenu(true);
      } else {
        openMenu();
      }
    });

    menu.querySelectorAll('a[href^="#"]').forEach((link) => {
      link.addEventListener('click', (event) => {
        const hash = link.getAttribute('href');
        if (!hash) return;
        event.preventDefault();
        closeMenu(false);
        window.setTimeout(() => scrollToHashTarget(hash), 200);
      });
    });

    document.addEventListener('keydown', (event) => {
      if (event.key !== 'Escape') return;
      if (button.getAttribute('aria-expanded') !== 'true') return;
      closeMenu(true);
    });

    menu.addEventListener('keydown', (event) => {
      if (!(event instanceof KeyboardEvent)) return;
      if (event.key !== 'Tab') return;
      if (button.getAttribute('aria-expanded') !== 'true') return;
      const focusables = getMenuFocusables();
      if (!focusables.length) return;
      const first = focusables[0];
      const last = focusables[focusables.length - 1];
      const active = document.activeElement;
      if (event.shiftKey && active === first) {
        event.preventDefault();
        if (last instanceof HTMLElement) last.focus();
      } else if (!event.shiftKey && active === last) {
        event.preventDefault();
        if (first instanceof HTMLElement) first.focus();
      }
    });
  };

  const initSmartHeader = () => {
    const header = document.querySelector('[data-smart-header]');
    const menuButton = document.querySelector('[data-mobile-menu-button]');
    if (!(header instanceof HTMLElement)) return;

    let lastY = window.scrollY;
    let ticking = false;

    const update = () => {
      const currentY = window.scrollY;
      const isDesktop = window.matchMedia('(min-width: 768px)').matches;
      const menuOpen =
        menuButton instanceof HTMLButtonElement &&
        menuButton.getAttribute('aria-expanded') === 'true';

      // Keep header visible at top, on mobile, or while mobile menu is open.
      if (!isDesktop || currentY < 80 || menuOpen) {
        header.classList.remove('-translate-y-full');
        lastY = currentY;
        ticking = false;
        return;
      }

      const delta = currentY - lastY;
      if (delta > 6) {
        header.classList.add('-translate-y-full');
      } else if (delta < -6) {
        header.classList.remove('-translate-y-full');
      }

      lastY = currentY;
      ticking = false;
    };

    window.addEventListener(
      'scroll',
      () => {
        if (ticking) return;
        ticking = true;
        window.requestAnimationFrame(update);
      },
      { passive: true }
    );

    header.addEventListener('focusin', () => {
      header.classList.remove('-translate-y-full');
    });
  };

  const initCollaboratorCarousel = () => {
    document.querySelectorAll('[data-collab-carousel]').forEach((root) => {
      if (root.dataset.ready === 'true') return;
      root.dataset.ready = 'true';

      const track = root.querySelector('[data-collab-track]');
      const prev = root.querySelector('[data-collab-prev]');
      const next = root.querySelector('[data-collab-next]');
      const status = root.querySelector('[data-collab-status]');
      const progress = root.querySelector('[data-collab-progress]');
      const reduceMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      const scrollBehavior = reduceMotion ? 'auto' : 'smooth';
      const slides = track instanceof HTMLElement ? Array.from(track.children).filter((child) => child instanceof HTMLElement) : [];
      const slideCount = slides.length;

      if (!(track instanceof HTMLElement) || !(prev instanceof HTMLButtonElement) || !(next instanceof HTMLButtonElement)) return;
      if (!(status instanceof HTMLElement)) return;
      if (!(progress instanceof HTMLElement)) return;

      const getMaxScroll = () => Math.max(0, track.scrollWidth - track.clientWidth);
      const getSnapPoints = () => {
        const maxScroll = getMaxScroll();
        if (!slideCount) return [0];
        return slides.map((slide, index) => {
          if (index === 0) return 0;
          if (index === slideCount - 1) return maxScroll;
          return Math.max(0, Math.min(maxScroll, slide.offsetLeft));
        });
      };

      const getIndex = () => {
        if (!slideCount) return 0;
        const snapPoints = getSnapPoints();
        const current = track.scrollLeft;
        let closestIndex = 0;
        let closestDistance = Number.POSITIVE_INFINITY;
        snapPoints.forEach((point, index) => {
          const distance = Math.abs(point - current);
          if (distance < closestDistance) {
            closestDistance = distance;
            closestIndex = index;
          }
        });
        return closestIndex;
      };

      let currentIndex = getIndex();

      const goToIndex = (index) => {
        const max = Math.max(slideCount - 1, 0);
        const clamped = Math.max(0, Math.min(max, index));
        currentIndex = clamped;
        const snapPoints = getSnapPoints();
        const left = snapPoints[clamped] ?? 0;
        track.scrollTo({ left, behavior: scrollBehavior });
      };

      prev.addEventListener('click', () => {
        goToIndex(currentIndex - 1);
      });

      next.addEventListener('click', () => {
        goToIndex(currentIndex + 1);
      });

      const setProgress = () => {
        if (!slideCount) return;
        currentIndex = getIndex();
        const index = currentIndex;
        status.textContent = `Slide ${index + 1} of ${slideCount}`;
        const dots = Array.from(progress.children).filter((child) => child instanceof HTMLElement);
        dots.forEach((dot, dotIndex) => {
          dot.classList.toggle('is-active', dotIndex === index);
        });
        prev.disabled = index === 0;
        next.disabled = index === slideCount - 1;
      };

      track.addEventListener('keydown', (event) => {
        if (!(event instanceof KeyboardEvent)) return;
        const current = currentIndex;
        if (event.key === 'ArrowRight') {
          event.preventDefault();
          goToIndex(current + 1);
        } else if (event.key === 'ArrowLeft') {
          event.preventDefault();
          goToIndex(current - 1);
        } else if (event.key === 'Home') {
          event.preventDefault();
          goToIndex(0);
        } else if (event.key === 'End') {
          event.preventDefault();
          goToIndex(slideCount - 1);
        }
      });

      track.addEventListener('scroll', setProgress, { passive: true });
      setProgress();
    });
  };

  const initContactFormFeedback = () => {
    const form = document.querySelector('[data-contact-form]');
    if (!(form instanceof HTMLFormElement)) return;
    const success = form.querySelector('[data-contact-success]');
    const error = form.querySelector('[data-contact-error]');
    const params = new URLSearchParams(window.location.search);

    if (params.get('contact') === 'success' && success instanceof HTMLElement) {
      success.classList.remove('hidden');
      if (error instanceof HTMLElement) error.classList.add('hidden');
    }

    form.addEventListener('submit', (event) => {
      if (form.checkValidity()) return;
      event.preventDefault();
      form.reportValidity();
      if (error instanceof HTMLElement) error.classList.remove('hidden');
      if (success instanceof HTMLElement) success.classList.add('hidden');
    });
  };

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      initScrollReveal();
      initMobileMenu();
      initSmartHeader();
      initCollaboratorCarousel();
      initContactFormFeedback();
    });
  } else {
    initScrollReveal();
    initMobileMenu();
    initSmartHeader();
    initCollaboratorCarousel();
    initContactFormFeedback();
  }
</script>
